[{"categories":["spring"],"content":"의존성 주입하는 방식과 추천 방법","date":"2020-08-20","objectID":"/spring_depedency_injection/","tags":["Spring","Dependency Injection"],"title":"스프링에 의존성 주입 방법","uri":"/spring_depedency_injection/"},{"categories":["spring"],"content":"의존성 주입 방법 종류 및 특징 ","date":"2020-08-20","objectID":"/spring_depedency_injection/:0:0","tags":["Spring","Dependency Injection"],"title":"스프링에 의존성 주입 방법","uri":"/spring_depedency_injection/"},{"categories":["spring"],"content":"1 서론 스프링 프레임워크를 사용하면서 컨트롤러에서 서비스 빈을 사용할 때에는 아래와 같이 필드 주입을 위해 @autowired 어노테이션을 사용하였다. @Controller public class TestController { @Autowired private TestService testService; .... } legacy 코드들을 통해 학습하면서, 필드 주입으로 간단하고 명확하게 사용하는 가장 좋은 방법이라고 생각하였다. 그러나 스프링 관련 동영상을 보다가 생성자 주입(Constructor Injection)을 사용하는 습관이 좋다라는 이야기를 듣고 주입에 대한 개념과 사용방법을 다시 한번 살펴보았다. ","date":"2020-08-20","objectID":"/spring_depedency_injection/:1:0","tags":["Spring","Dependency Injection"],"title":"스프링에 의존성 주입 방법","uri":"/spring_depedency_injection/"},{"categories":["spring"],"content":"2 주입 종류 및 예 ","date":"2020-08-20","objectID":"/spring_depedency_injection/:2:0","tags":["Spring","Dependency Injection"],"title":"스프링에 의존성 주입 방법","uri":"/spring_depedency_injection/"},{"categories":["spring"],"content":"2.1 생성자 주입(Constructor Injection) 스프링 가이드에 권장 방식으로 생성자에 @Autowired를 통해 주입을 할 수 있다. 단일 생성자에는 생략이 가능하며 2개이상의 생성자를 가지는 경우 @autowired 어노테이션을 전부 붙여주어야 한다. 생성자 객체를 생성할 때 빈을 주입되기 때문에 생성전 필요한 빈들을 찾게 된다. 다른 주입 방식들과의 차이점이며, 이 특징은 순환 참조(Circular Depencies)등의 방지가 가능하다. @Component public class TestComponent { private final TestService testService; // 단일 생성자인경우 @Autowired 생략이 가능 public TestComponent(TestService testService){ this.testService = testService; } } ","date":"2020-08-20","objectID":"/spring_depedency_injection/:2:1","tags":["Spring","Dependency Injection"],"title":"스프링에 의존성 주입 방법","uri":"/spring_depedency_injection/"},{"categories":["spring"],"content":"2.2 필드 주입(Field Injection) 필드 주입은 가독성 및 사용하기 편리하다. 필드 주입의 경우 빈을 생성한 후에 어노테이션이 붙은 필드에 해당하는 빈을 주입하는 방식이다. @Component public class TestComponent { @Autowired private TestService testService; ... } ","date":"2020-08-20","objectID":"/spring_depedency_injection/:2:2","tags":["Spring","Dependency Injection"],"title":"스프링에 의존성 주입 방법","uri":"/spring_depedency_injection/"},{"categories":["spring"],"content":"2.3 수정자 주입(Setter Injection) 수정자(Setter)를 사용한 방법으로 클래스의 캡슐화시 변수들을 getter/setter로 사용하는 방식과 동일하다. TestComponent 빈이 생성이 된 후 setTestService 메소드 호출을 통해 주입 되는 방식이며, 생성자 주입과 빈이 생성되는 순서가 다르기 때문에 final 사용은 불가능하다. @Component public class TestComponent { private TestService testService; @Autowired private void setTestService(TestService testService){ this.testService = testService; } } ","date":"2020-08-20","objectID":"/spring_depedency_injection/:2:3","tags":["Spring","Dependency Injection"],"title":"스프링에 의존성 주입 방법","uri":"/spring_depedency_injection/"},{"categories":["spring"],"content":"3 생성자 주입 방법을 써야하는 이유 ","date":"2020-08-20","objectID":"/spring_depedency_injection/:3:0","tags":["Spring","Dependency Injection"],"title":"스프링에 의존성 주입 방법","uri":"/spring_depedency_injection/"},{"categories":["spring"],"content":"3.1 순환 참조를 방지 @Service public class TestAService { @Autowired private TestBService testBService; private void callTestB(){ testBService.callTestA(); } } @Service public class TestBService { @Autowired private TestAService testAService; private void callTestA(){ testAService.callTestB(); } } 위 2개의 클래스 TestAService, TestBService 필드 주입을 통해 상호 서비스간의 참조하고 메소드들도 서로 참조하여 메소드 실행시에 stackOverflow가 발생하는 예제의 코드이다. (상호 참조하지 않는다면 문제가 발생할만한 비즈니스 로직상에 순환참조도 없을것이다.) 위 2개의 클래스를 가지는 어플리케이션을 구동하게 되면 각 서비스들의 빈이 생성이 된 후, 각자 의존성이 있는 빈이 컨테이너에 존재하기 때문에 실행에는 아무런 오류가 발생하지 않는다. @Service public class TestAService { private final TestBService testBService; public TestAService(TestBService testBService){ this.testBService = testBservice; } private void callTestB(){ testBService.callTestA(); } } @Service public class TestBService { private final TestAService testAService; public TestBService(TestAService testAService){ this.testAService = testAservice; } private void callTestA(){ testAService.callTestB(); } } 이번에는 생성자 주입을 통해 코드를 구성하였다. 자신의 빈을 생성하기 전에 의존성 있는 빈들을 검색하기 때문에 2개의 서비스 모두 생성되지 않고, 계속 서로의 생성자를 호출하게 되며, 스프링에서는 이것을 순환참조로 감지하여 오류 메세지를 전달한다. 어플리케이션을 동작시키면 다음과 같은 로그를 확인 할 수 있다. Log Description : The dependencies of some of the beans in the application context from a cycle ","date":"2020-08-20","objectID":"/spring_depedency_injection/:3:1","tags":["Spring","Dependency Injection"],"title":"스프링에 의존성 주입 방법","uri":"/spring_depedency_injection/"},{"categories":["spring"],"content":"4 회고 요약하자면 생성자 주입을 사용하면 컴파일 타임에 NPE 방지하면 객체를 생성하고, 순환참조도 가능하며, immutabliliy하게 final을 사용할 수 있다. 생성자 주입을 사용하도록 하자~! ","date":"2020-08-20","objectID":"/spring_depedency_injection/:4:0","tags":["Spring","Dependency Injection"],"title":"스프링에 의존성 주입 방법","uri":"/spring_depedency_injection/"},{"categories":["spring"],"content":"5 참조 스프링 - 생성자 주입을 사용해야 하는 이유, 필드인젝션이 좋지 않은 이유 순환 참조 해결하기 ","date":"2020-08-20","objectID":"/spring_depedency_injection/:5:0","tags":["Spring","Dependency Injection"],"title":"스프링에 의존성 주입 방법","uri":"/spring_depedency_injection/"},{"categories":["Java"],"content":"Hikari cp의 원리를 설명한다.","date":"2020-06-30","objectID":"/hikaricp/","tags":["ConnectionPool","Java"],"title":"Hikari Connection Pool 파헤치기","uri":"/hikaricp/"},{"categories":["Java"],"content":"Hikari Connection Pool 동작 원리 및 옵션 설정 이해하기 CP(Connection Pool) 라이브러리 성능 검증 을 통해 Hikari 성능이 좋다는 것은 확인하였고, 실제 동작상 성능 향상을 위해 어떠한 이점을 가지는지를 확인하고자 동작 방식과 hikari에서 사용되는 옵션들에 대해서 이해해 보자. ","date":"2020-06-30","objectID":"/hikaricp/:0:0","tags":["ConnectionPool","Java"],"title":"Hikari Connection Pool 파헤치기","uri":"/hikaricp/"},{"categories":["Java"],"content":"1 Description 기존 사용되던 tomcat-dbcp, dbcp, bonecp 보다 더 빠르고, 가벼운 Connection Pool로 ‘zero-overhead’라고 할 정도의 경량화 된 라이브러리이다. hikari cp가 빠른 이유 코드 디자인 및 최적화를 통해 스레드 간의 잠금 경쟁이 크게 감소 JDK 및 cglib의 동적 프록시와 비교하여 javaassist(java 바이트 코드를 조작하는 수단을 제공하는 라이브러리)를 통해 클래스 파일을 직접 수정하여 생성된 프록시 클래스는 작동 속도가 빠름 FastList 및 사용자 정의 컬렉션 클래스 도입하여 세부 로직을 최적화하여 제공 ","date":"2020-06-30","objectID":"/hikaricp/:1:0","tags":["ConnectionPool","Java"],"title":"Hikari Connection Pool 파헤치기","uri":"/hikaricp/"},{"categories":["Java"],"content":"2 Architecture 다른 DBCP들과 아키텍쳐들은 유사하며, 아키텍쳐의 차이에 의한 성능차이가 아닌 pool(ConcurrentBag) 구조 및 관리 방법에 의한 것임을 확인 할 수 있습니다. GROUP Modules Description JMX HikariCOnfigMXBean, HikariPoolMXBean 데이터 수집을 통한 모니터링 제공 설정정보 HikariConfig 옵션 Connection Pool PoolBase, IBagStateListner, HikiarPool, ConcurrentBag Connection 관리 DataSource DataSource, HikariDataSource, Closeable Connection Pool을 지원하기 위한 인터페이스 Hikari Pool 구성도Minion \" Hikari Pool 구성도 ","date":"2020-06-30","objectID":"/hikaricp/:2:0","tags":["ConnectionPool","Java"],"title":"Hikari Connection Pool 파헤치기","uri":"/hikaricp/"},{"categories":["Java"],"content":"3 설명 ","date":"2020-06-30","objectID":"/hikaricp/:3:0","tags":["ConnectionPool","Java"],"title":"Hikari Connection Pool 파헤치기","uri":"/hikaricp/"},{"categories":["Java"],"content":"3.1 특징 hikari CP의 특이점이 있다면 아래 코드와 같이 DataSource에 2개의 pool이 존재한다는 것이다. fastPathPool은 전체 pool에서 요청전에 캐시 처럼 사용한다.(volatile을 사용하는 경우 메인메모리에 read/write를 수행하여 일치되는 값을 공유하여 사용할 수 있지만 오버헤드가 있다.) public class HikariDataSource extends HikariConfig implements DataSource, Closeable { private final HikariPool fastPathPool; private volatile HikariPool pool; } 다수의 connection이 동시에 연결/닫기 를 수행했을 때의 병목을 방지 하기 위해서 maxLifeTime의 2.5% 수준의 변화를 주어 timeout값을 설정하여 스케쥴에 등록한다. maxLifeTime 설정된 시간 만큼 connection 을 유지만 하고 갱신하지 않는다.(갱신에 따른 오버헤드 제거) ","date":"2020-06-30","objectID":"/hikaricp/:3:1","tags":["ConnectionPool","Java"],"title":"Hikari Connection Pool 파헤치기","uri":"/hikaricp/"},{"categories":["Java"],"content":"3.2 동작 순서 3.2.1 Connection 가져오기 fastPathPool에서 대여 이력이 있는지를 확인하여 이력이 있는 경우 Connection 요청 fastPathPool에 없으면 Pool에서 Connection 요청 Pool에도 없다면 handoffQueue에서 대기 일정 시간 이내 다른 thread에게 connection이 반납되지 않으면 Exception 발생 Connection이 1000ms(1초) 이내 사용된 경우에는 유효성 검증을 하지 않는다. 3.2.2 Connection 닫기 idle connection으로 변경(state를 STATE_NOT_IN_USE로 변경) handOffQueue에서 대기 쓰레드가 있는지를 확인하여 connection 전달 없다면 pool로 삽입 connection 대여 이력 추가 ","date":"2020-06-30","objectID":"/hikaricp/:3:2","tags":["ConnectionPool","Java"],"title":"Hikari Connection Pool 파헤치기","uri":"/hikaricp/"},{"categories":["Java"],"content":"3.3 주의사항 HikariCP는 test-while-idle Connection 갱신하여 사용하는 것을 권장하지 않는다.(강제 설정하는 것은 가능) maxLifeTime만큼만 connection을 유지하고 새로운 connection을 생성하여 사용한다.(불필요한 Validation Query가 발생하지 않음) **maxLifeTime은 DB의 waitTimeout보다는 작은 값을 설정해야 한다.(2~5 초 : 문서상 30초는 업데이트가 안된거라고 함) ** (참고) HikariCP는 test-while-idle과 같은 커넥션 갱신 기능이 없을까? ","date":"2020-06-30","objectID":"/hikaricp/:3:3","tags":["ConnectionPool","Java"],"title":"Hikari Connection Pool 파헤치기","uri":"/hikaricp/"},{"categories":["Java"],"content":"4 옵션 ","date":"2020-06-30","objectID":"/hikaricp/:4:0","tags":["ConnectionPool","Java"],"title":"Hikari Connection Pool 파헤치기","uri":"/hikaricp/"},{"categories":["Java"],"content":"4.1 Essentials Option Description dataSourceClassName datasource JDBC 드라이버가 제공하는 클래스 이름 jdbcUrl db 접속 url username 사용자명 password 사용자 비밀번호 ","date":"2020-06-30","objectID":"/hikaricp/:4:1","tags":["ConnectionPool","Java"],"title":"Hikari Connection Pool 파헤치기","uri":"/hikaricp/"},{"categories":["Java"],"content":"4.2 Optionals(Frequently used) Option Description autoCommit connection 반납시 commit 여부(default:true) connectionTimeout connection 연결시도시 타임아웃 값 (default:30000(30초)) idleTimeout connection pool에서 유휴 상태의 생명주기 (default:600000(10분)) maxLifetime connection 의 최대 생명주기 (default:1800000(30분)) connectionTestQuery 드라이버가 JDBC4를 지원하는 경우에는 설정하지 않음. legacy 드라이버를 위해 사용 minimumIdle 최소 연결 유휴 connection 수 maximumPoolSize 최대 연결 connection 수 metricRegistry 모니터링용. metric을 기록하는데 사용할 Codahale/Dropwizard의 인스턴스를 지정 healthCheckRegistry 모니터링용. health check 정보를 사용할 Codahale/Dropwizard의 인스턴스를 지정 poolName connection pool의 사용자 이름 정의 ","date":"2020-06-30","objectID":"/hikaricp/:4:2","tags":["ConnectionPool","Java"],"title":"Hikari Connection Pool 파헤치기","uri":"/hikaricp/"},{"categories":["Java"],"content":"4.3 Optionals(Infrequently used) Option Description initializationFailTimeout 초기 연결로 풀에 시드 connection으로 할 수 없을 경우 실패 여부를 제어 (default:1) isolateInternalQueries 서비스용이 아닌 테스트와 같은 내부 풀 쿼리를 분리 여부를 결정. autoCommit이 비활성화된 경우에만 적용 allowPoolSuspension JMX를 통해 pool을 일시 중단하고 재개할 수 있는지 여부를 제어. 특정 장애 조치 자동화 시나리오에 유용 (default:false) readOnly 읽기모드 전용. 데이터베이스 지원여부를 확인하고 사용 가능(default:false) registerMbeans JMX 관리 Bean의 등록 여부 제어 (default:false) catalog 카탈로그 개념을 지원하는 데이터베이스의 기본 카탈로그를 설정. 지정하지 않으면 JDBC 드라이버가 정의한 기본 카탈로그를 사용 connectionInitSql 신규 connection이 pool에 추가되기 전에 실행된 SQL 문 정의 driverClassName 특정 DriverManager를 실행하기 위해 지정하는 특정 Class를 지정 transactionIsolation java.sql.Connection에 지정된 Transaction Isolation 설정 (default:none) validationTimeout connection의 유효한지를 확인할 경우의 타이아웃 값 (default:5000) leakDetectionThreshold connection 이 pool에서 벗어나는 시간을 제어. 누수 여부를 검출시 사용 (default:0) dataSource hikariCP가 reflection을 통해 생성하지 않고 풀의 인스턴스를 바로 랩핑하는 겨우 설정 schema 스키마 개념을 지원하는 데이터베이스의 기본 스키마를 설정 (default:driver default) threadFactory 쓰레드 생성시에 사용할 인스턴스를 지정 scheduledExecutor java.util.concurrent.ScheduledExecutorService 내부적으로 예약 된 다양한 작업에 사용될 인스턴스를 설정 가능 ","date":"2020-06-30","objectID":"/hikaricp/:4:3","tags":["ConnectionPool","Java"],"title":"Hikari Connection Pool 파헤치기","uri":"/hikaricp/"},{"categories":["Java"],"content":"5 참조 HikariCP Dead lock에서 벗어나기 (이론편) JDBC 커넥션 풀들의 리소스 관리 방식 이해하기 Commons DBCP 이해하기 HikariCP 뜯어보기 1편 HikariCP 뜯어보기 2편 HikariCP Failed to Validate Connection Warning 이야기 HikariCP는 test-while-idle과 같은 커넥션 갱신 기능이 없을까? HikariCP Maximum Pool Size 설정 시, 고려해야할 부분 ","date":"2020-06-30","objectID":"/hikaricp/:5:0","tags":["ConnectionPool","Java"],"title":"Hikari Connection Pool 파헤치기","uri":"/hikaricp/"},{"categories":["Java"],"content":"Connection Pool 성능테스트","date":"2020-06-29","objectID":"/connection_pool_benchmark/","tags":["ConnectionPool","Benchmark","Java"],"title":"Connection Pool 성능테스트 : hikari, tomcat-dbcp, bee, vibur","uri":"/connection_pool_benchmark/"},{"categories":["Java"],"content":"Connectino Pool 라이브러리 tomcat-dbcp/vibur/bee/hikari 최신 라이브러리 적용한 성능 검증 분석 회사에서 스프링 프레임워크 업그레이드를 진행하면서 의존성 있는 라이브러리의 목록을 업데이트하는 업무를 진행하게 되었다. 사용하는 라이브러리 중에서 CP(Connection Pool)는 tomcat-dbcp를 사용하고 있었고, 스프링부트 2.0에서 디폴트로 적용된 Hikari CP에 대해 검토하게 되었다. Hikari CP Repository에 성능 비교는 2-3년 전에 진행되었기 때문에 최신 버전과 새로운 CP 라이브러리를 추가하여 성능검증을 진행하였다. ","date":"2020-06-29","objectID":"/connection_pool_benchmark/:0:0","tags":["ConnectionPool","Benchmark","Java"],"title":"Connection Pool 성능테스트 : hikari, tomcat-dbcp, bee, vibur","uri":"/connection_pool_benchmark/"},{"categories":["Java"],"content":"1 성능검증 ","date":"2020-06-29","objectID":"/connection_pool_benchmark/:1:0","tags":["ConnectionPool","Benchmark","Java"],"title":"Connection Pool 성능테스트 : hikari, tomcat-dbcp, bee, vibur","uri":"/connection_pool_benchmark/"},{"categories":["Java"],"content":"1.1 테스트 환경 항목 SPEC OS CentOS 7.7.1908(x86_64) CPU Intel(R) Xeon(R) CPU E5-2660 v2 @2.20GHz,GenuineIntel RAM 8GB JDK openjdk 1.8 ","date":"2020-06-29","objectID":"/connection_pool_benchmark/:1:1","tags":["ConnectionPool","Benchmark","Java"],"title":"Connection Pool 성능테스트 : hikari, tomcat-dbcp, bee, vibur","uri":"/connection_pool_benchmark/"},{"categories":["Java"],"content":"1.2 테스트 대상 라이브러리 라이브러리명 버전 RELEASE 일자 비고 tomcat-dbcp 8.0.53 2018.01.29. dbcp2에 개선 버전이기에 dbcp2를 따로 테스트 항목에 추가하지 않음 hikari 3.4.5 2020.05.08. bee 2.4.2 2020.05.30. vibur 25.0 2019.11.30. ","date":"2020-06-29","objectID":"/connection_pool_benchmark/:1:2","tags":["ConnectionPool","Benchmark","Java"],"title":"Connection Pool 성능테스트 : hikari, tomcat-dbcp, bee, vibur","uri":"/connection_pool_benchmark/"},{"categories":["Java"],"content":"1.3 CP 설정 및 실행 조건 Contended benchmark 테스트로 진행 항목 설정 값 쓰레드 수 32 초기 커넥션 수 20 최대 커넥션 수 20 ","date":"2020-06-29","objectID":"/connection_pool_benchmark/:1:3","tags":["ConnectionPool","Benchmark","Java"],"title":"Connection Pool 성능테스트 : hikari, tomcat-dbcp, bee, vibur","uri":"/connection_pool_benchmark/"},{"categories":["Java"],"content":"1.4 기타 기존 성능 테스트를 위해 구현되었던 HikariCP-benchmark 프로젝트를 기반으로 코드를 재작성하였다. Repository : https://github.com/qnqnckck/ConnectionPoolBenchmark ","date":"2020-06-29","objectID":"/connection_pool_benchmark/:1:4","tags":["ConnectionPool","Benchmark","Java"],"title":"Connection Pool 성능테스트 : hikari, tomcat-dbcp, bee, vibur","uri":"/connection_pool_benchmark/"},{"categories":["Java"],"content":"2 결과 Cycle Connection과 Cycle Statement 2가지 테스트를 진행한다. Cycle Connection : DataSource.getConnection(), Connection.close() Cycle Statement : Connecdtion.prepareStatement(), Statement.execute(), Statement.close() ","date":"2020-06-29","objectID":"/connection_pool_benchmark/:2:0","tags":["ConnectionPool","Benchmark","Java"],"title":"Connection Pool 성능테스트 : hikari, tomcat-dbcp, bee, vibur","uri":"/connection_pool_benchmark/"},{"categories":["Java"],"content":"2.1 Stub Driver 사용 2.1.1 Cycle Connection tomcat-dbcp hikari bee vibur ms당 수행횟수(ops/ms) 1921.732 27429.626 45446.493 2930.534 2.1.2 Cycle Statement tomcat-dbcp hikari bee vibur ms당 수행횟수(ops/ms) 20316.572 28529.254 75904.932 20487.692 ","date":"2020-06-29","objectID":"/connection_pool_benchmark/:2:1","tags":["ConnectionPool","Benchmark","Java"],"title":"Connection Pool 성능테스트 : hikari, tomcat-dbcp, bee, vibur","uri":"/connection_pool_benchmark/"},{"categories":["Java"],"content":"2.2 MySql Driver 사용 2.2.1 Cycle Connection tomcat-dbcp hikari bee vibur ms당 수행횟수(ops/ms) 12.961 31431.702 58562.068 3033.819 2.2.2 Cycle Statement tomcat-dbcp hikari bee vibur ms당 수행횟수(ops/ms) 12.341 12.228 12.455 12.298 ","date":"2020-06-29","objectID":"/connection_pool_benchmark/:2:2","tags":["ConnectionPool","Benchmark","Java"],"title":"Connection Pool 성능테스트 : hikari, tomcat-dbcp, bee, vibur","uri":"/connection_pool_benchmark/"},{"categories":["Java"],"content":"3 분석 Stub 드라이버의 경우 DB 서버 실제 질의를 날리지 않기 때문에 순수 라이브러리의 성능지표이며, 결과만 보면 압도적으로 hikari와 bee 라이브러리가 가장 좋은 성능을 보여주었다. mysql 드라이버의 경우 private 회사망에 분리되어 있는 DB 서버에 접속하여 테스트를 진행하였으며 실제 질의 후 응답까지에 네트워크 시간을 포함한 소요시간이 가장 큰 영향을 끼치기 때문에 거의 유사하 결과를 확인 할 수 있었다. 그렇다면 응답 속도도 동일하면 성능적으로 차이가 없는 것인가? 그렇지 않다. 각각의 라이브러리의 장점들이 있을텐데 hikari의 경우에는 connection을 fastPathPool을 통해 동일 쓰레드 요청에 대 이전에 사용된 connection을 전달해 준다. 이부분에 대해서 성능은 실제 얼마나 응답속도 부분에 대해 기여할지는 추후에 테스트하게 되면 공유 하도록 하겠다. ","date":"2020-06-29","objectID":"/connection_pool_benchmark/:3:0","tags":["ConnectionPool","Benchmark","Java"],"title":"Connection Pool 성능테스트 : hikari, tomcat-dbcp, bee, vibur","uri":"/connection_pool_benchmark/"},{"categories":null,"content":"  LoveIt is a clean, elegant but advanced blog theme for Hugo developed by Dillon. It is based on the original LeaveIt Theme and KeepIt Theme. Hugo Theme LoveItHugo Theme LoveIt \" Hugo Theme LoveIt ","date":"2019-08-02","objectID":"/about/:0:0","tags":null,"title":"About LoveIt","uri":"/about/"},{"categories":null,"content":"Features Performance and SEO  Optimized for performance: 99/100 on mobile and 100/100 on desktop in Google PageSpeed Insights  Optimized SEO performance with a correct SEO SCHEMA based on JSON-LD  Google Analytics supported  Fathom Analytics supported  Search engine verification supported (Google, Bind, Yandex and Baidu)  CDN for third-party libraries supported  Automatically converted images with Lazy Load by lazysizes Appearance and Layout / Responsive layout / Light/Dark mode  Globally consistent design language  Pagination supported  Easy-to-use and self-expanding table of contents  Multilanguage supported and i18n ready  Beautiful CSS animation Social and Comment Systems  Gravatar supported by Gravatar  Local Avatar supported  Up to 64 social links supported  Up to 28 share sites supported  Disqus comment system supported by Disqus  Gitalk comment system supported by Gitalk  Valine comment system supported by Valine  Facebook comments system supported by Facebook  Telegram comments system supported by Comments  Commento comment system supported by Commento  Utterances comment system supported by Utterances Extended Features  Search supported by Lunr.js or algolia  Twemoji supported  Automatically highlighting code  Copy code to clipboard with one click  Images gallery supported by lightgallery.js  Extended Markdown syntax for Font Awesome icons  Extended Markdown syntax for ruby annotation  Extended Markdown syntax for fraction  Mathematical formula supported by $ \\KaTeX $  Diagrams shortcode supported by mermaid  Interactive data visualization shortcode supported by ECharts  Mapbox shortcode supported by Mapbox GL JS  Music player shortcode supported by APlayer and MetingJS  Bilibili player shortcode  Kinds of admonitions shortcode  Custom style shortcode  Custom script shortcode  Animated typing supported by TypeIt  Dynamic scroll supported by Smooth Scroll  Cookie consent banner supported by cookieconsent … ","date":"2019-08-02","objectID":"/about/:0:1","tags":null,"title":"About LoveIt","uri":"/about/"},{"categories":null,"content":"License LoveIt is licensed under the MIT license. Check the LICENSE file for details. Thanks to the authors of following resources included in the theme: normalize.css Font Awesome Simple Icons Animate.css Smooth Scroll autocomplete.js Lunr.js algoliasearch lazysizes object-fit-images Twemoji lightgallery.js clipboard.js Sharer.js TypeIt $ \\KaTeX $ mermaid ECharts Mapbox GL JS APlayer MetingJS Gitalk Valine cookieconsent ","date":"2019-08-02","objectID":"/about/:0:2","tags":null,"title":"About LoveIt","uri":"/about/"}]